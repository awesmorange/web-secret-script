# 闭包
匿名函数经常被人误认为是闭包（closure）​。**闭包**指的是那些**引用了另一个函数作用域中变量的函数**，通常是在**嵌套函数**中实现的。

## 作用域链创建和使用
理解作用域链创建和使用的细节对理解闭包非常重要。
- 在**调用**一个**函数**时，会为这个函数调用创建一个**执行上下文**，并创建一个**作用域链**。
- 然后用**arguments**和**其他命名参数**来**初始化**这个函数的**活动对象**。
- **外部函数**的**活动对象**是**内部函数 作用域链上** 的**第二个对象**。
- 这个**作用域链**一直向外**串起了所有包含函数的活动对象**，直到**全局执行上下文才终止**。

``` javascript
function compare(value1, value2) {
    if (value1 < value2) {
        return -1;
    } else if (value1 > value2) {
        return 1;
    } else {
        return 0;
    }
}
let result = compare(5, 10);
```
![执行上下文、作用域立案、全局变量对象、活动对象示意图](./image.png)

- 函数执行时，每个**执行上下文**中都会有一个包含其中**变量的对象**。**全局上下文**中的叫**变量对象**，它会在**代码执行期间**始终存在。而函数**局部上下文**中的叫活动对象，只在**函数执行期间**存在。
- 在**定义**compare()函数时，就会为它**创建作用域链**，**预装载**全局变量对象，并保存在内部的[​[Scope]​]中。
- 在**调用**这个函数时，会**创建**相应的**执行上下文**，然后通过**复制**函数的[​[Scope]​]来**创建其作用域链**。
- 接着会**创建**函数的**活动对象**（用作变量对象）并将其**推入作用域链**的**前端**。

这意味着compare()函数执行上下文的作用域链中有两个变量对象：**局部变量对象**和**全局变量对象**。**作用域链**其实是一个**包含指针的列表**，每个指针分别指向一个变量对象，但**物理上**并**不会包含相应的对象**。

函数**内部**的代码在**访问变量**时，就会使用给定的名称从**作用域链中查找**变量。函数**执行完毕**后，**局部活动对象**会被**销毁**，内存中就**只剩**下**全局作用域**。不过，闭包就不一样了。

## 闭包
在一个函数**内部定义的函数**会把其**包含函数的活动对象**添**加**到自己的**作用域链**中。
![alt text](image-1.png)

``` javascript
function createComparisonFunction(propertyName) {
    return function (object1, object2) {
        let value1 = object1[propertyName];
        let value2 = object2[propertyName];
        if (value1 < value2) {
            return -1;
        } else if (value1 > value2) {
            return 1;
        } else {
            return 0;
        }
    };
}
let compare = createComparisonFunction('name');
let result = compare({ name: 'Nicholas' }, { name: 'Matt' });
```
**匿名函数**就可以访问到createComparison-Function()可以**访问的所有变量**。另一个有意思的**副作用**就是，createComparisonFunction()的**活动对象**并**不能**在它**执行完毕后销毁**，因为**匿名函数的作用域链中仍然有对它的引用**。在create-ComparisonFunction()执行完毕后，其**执行上下文的作用域链会销毁**，但它的活动对象仍然会保留在内存中，**直到匿名函数被销毁后才会被销毁**。

``` javascript
// 创建比较函数
let compareNames = createComparisonFunction('name');
// 调用函数
let result = compareNames({ name: 'Nicholas' }, { name: 'Matt' });
// 解除对函数的引用，这样就可以释放内存了
compareNames = null;
```
把compareNames设置为等于**null**会**解除对函数的引用**，从而让**垃圾回收程序**可以将**内存释放**掉。**作用域链**也会被销毁，**其他作用域（除全局作用域之外）**也可以**销毁**。

### 注意
因为**闭包**会保留它们包含函数的作用域，所以**比其他函数更占用内存**。**过度使用**闭包可能导致**内存过度占用**，因此建议仅在十分必要时使用。V8等优化的JavaScript引擎会努力回收被闭包困住的内存，不过我们还是建议在使用闭包时要**谨慎**。

## this对象

## 内存泄露

